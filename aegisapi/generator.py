import pathlib, json, re, yaml
from jinja2 import Template
from .ingestion import openapi_loader
from .telemetry import log_event

TEST_TEMPLATE = """# Generated by AegisAPI Agent
import httpx, json
from jsonschema import validate
BASE_URL="{{ base_url }}"
{% for t in tests %}
def test_{{ t.test_name }}():
    with httpx.Client(timeout=10) as client:
        resp = client.request("{{ t.method }}", BASE_URL + "{{ t.path_resolved }}", params={{ t.params }}, json={{ t.body }}, headers={"Accept":"application/json"})
    assert resp.status_code in {{ t.expected_statuses }}
    schema = {{ t.response_schema | tojson }}
    if schema:
        try: payload = resp.json()
        except Exception: payload = None
        if payload is not None:
            validate(instance=payload, schema=schema)
{% endfor %}
"""

def sanitize(name: str):
    return re.sub(r"[^a-zA-Z0-9_]+", "_", name)

def _pick_statuses(op):
    resps = (op.get("responses") or {})
    twos = [int(k) for k in resps.keys() if str(k).startswith("2")]
    return twos or [200,201,204]

def _response_schema(op):
    r = (op.get("responses") or {}).get("200") or {}
    sch = ((r.get("content") or {}).get("application/json") or {}).get("schema",{})
    return sch or {}

def _synthesize_params(op):
    out = {}
    for p in (op.get("parameters") or []):
        name = p.get("name"); schema = (p.get("schema") or {}); t = schema.get("type","string")
        eg = p.get("example") or schema.get("example")
        if eg is not None: out[name] = eg; continue
        if t == "integer": out[name] = schema.get("minimum", 1)
        elif t == "boolean": out[name] = True
        else: out[name] = "demo"
    return out

def _load_patches():
    p = pathlib.Path("healer_patches.yaml")
    if not p.exists(): return {}
    try: return yaml.safe_load(p.read_text(encoding="utf-8")) or {}
    except Exception: return {}

def _apply_schema_renames(schema: dict, patches: dict) -> dict:
    renames = [(r.get("from"), r.get("to")) for r in (patches.get("renames") or [])]
    if not renames: return schema
    props = (schema.get("properties") or {})
    for old, new in renames:
        if old in props and new not in props:
            props[new] = props.pop(old)
    schema["properties"] = props
    req = schema.get("required") or []
    for i, r in enumerate(req):
        for old, new in renames:
            if r == old: req[i] = new
    schema["required"] = req
    return schema

def generate_tests(spec_path: str, out_dir: pathlib.Path, auth_profile: str="none"):
    spec = openapi_loader.load(spec_path)
    base_url = (spec.get("servers") or [{"url":""}])[0].get("url","")
    out_dir.mkdir(parents=True, exist_ok=True)

    patches = _load_patches()
    tests = []
    for path, item in (spec.get("paths") or {}).items():
        for method, op in (item or {}).items():
            if method.lower() not in ("get","post","put","patch","delete"): continue
            test_name = sanitize(f"{method}_{path.strip('/').replace('/','_') or 'root'}")
            params = _synthesize_params(op)
            sch = _apply_schema_renames(_response_schema(op), patches)
            tests.append({
                "test_name": test_name,
                "path_resolved": path,
                "method": method.upper(),
                "params": params,
                "body": {},
                "expected_statuses": _pick_statuses(op),
                "response_schema": sch,
            })

    rendered = Template(TEST_TEMPLATE).render(base_url=base_url, tests=tests)
    (out_dir / "test_generated_api.py").write_text(rendered, encoding="utf-8")
    log_event({"type":"test_generated","summary":f"{len(tests)} tests -> {out_dir}"})
